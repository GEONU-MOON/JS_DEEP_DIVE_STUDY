
## 23.1 실행컨텍스트의 타입

<!-- 표 -->
| 타입 | 설명 |
| --- | --- |
| 전역 실행 컨텍스트 | 코드가 실행되기 전에 생성되는 실행 컨텍스트 |
| 함수 실행 컨텍스트 | 함수가 호출될 때 생성되는 실행 컨텍스트 |
| eval 실행 컨텍스트 | eval 함수로 실행될 때 생성되는 실행 컨텍스트 |
| 모듈 실행 컨텍스트 | 모듈이 호출될 때 생성되는 실행 컨텍스트 |


1. 외부환경참조 
-> 바깥 Lexical Environment를 가리키는데,

Record +  Outer  = Lexical Environment

### 실행컨텍스트란 ? 
> 코드를 실행하는데 필요한 환경을 제공하는 객체
- 환경 : 코드 실행에 영향을 주는 조건이나 상태

- 식별자 결정을 더욱 효율적으로 하기 위한 수단 



## 실행 컨텍스트 시각화

```javascript
function first() {
  console.log("첫 번째 함수 실행");
  second();
}

function second() {
  console.log("두 번째 함수 실행");
  third();
}

function third() {
  console.log("세 번째 함수 실행");
}

first(); // 실행 시작
```

**1. 전역 실행 컨텍스트 생성:**

- 자바스크립트 엔진이 코드 실행을 시작하면 먼저 **전역 실행 컨텍스트**가 생성됩니다.
- 콜 스택에는 전역 실행 컨텍스트가 가장 아래에 위치합니다.
- 전역 변수와 함수 선언들이 메모리에 할당됩니다. (예: `first`, `second`, `third`)

```
[전역 실행 컨텍스트]
```

**2. first() 함수 호출:**

- `first()` 함수가 호출되면 새로운 **함수 실행 컨텍스트**가 생성됩니다.
- 이 실행 컨텍스트는 콜 스택의 맨 위에 푸시됩니다.
- `first()` 함수 내부의 변수와 함수 인자들이 메모리에 할당됩니다.

```
[first() 실행 컨텍스트]
[전역 실행 컨텍스트]
```

**3. second() 함수 호출:**

- `first()` 함수 내부에서 `second()` 함수가 호출되면 또 다른 **함수 실행 컨텍스트**가 생성됩니다.
- 이 실행 컨텍스트는 콜 스택의 맨 위에 푸시됩니다.
- `second()` 함수 내부의 변수와 함수 인자들이 메모리에 할당됩니다.

```
[second() 실행 컨텍스트]
[first() 실행 컨텍스트]
[전역 실행 컨텍스트]
```

**4. third() 함수 호출:**

- `second()` 함수 내부에서 `third()` 함수가 호출되면 마찬가지로 새로운 **함수 실행 컨텍스트**가 생성되고 콜 스택의 맨 위에 푸시됩니다.
- `third()` 함수 내부에는 변수나 인자가 없으므로 메모리 할당은 없습니다.

```
[third() 실행 컨텍스트]
[second() 실행 컨텍스트]
[first() 실행 컨텍스트]
[전역 실행 컨텍스트]
```

**5. 실행 컨텍스트 종료:**

- `third()` 함수 실행이 완료되면 해당 실행 컨텍스트는 콜 스택에서 팝되어 제거됩니다.
- 이어서 `second()`, `first()` 함수 실행 컨텍스트도 차례로 팝되어 제거됩니다.
- 최종적으로 콜 스택에는 전역 실행 컨텍스트만 남게 됩니다.

```
[전역 실행 컨텍스트]
```

**6. 전역 실행 컨텍스트 종료:**

- 모든 코드 실행이 완료되면 전역 실행 컨텍스트도 콜 스택에서 팝되어 제거됩니다.
- 콜 스택은 비어 있는 상태가 됩니다.

--------

### **콜 스택과 스코프 체인의 관계**

1. **실행 컨텍스트와 스코프:** 각 실행 컨텍스트는 자신만의 스코프를 가집니다. 전역 실행 컨텍스트는 전역 스코프를, 함수 실행 컨텍스트는 지역 스코프를 가집니다. 이 스코프는 해당 실행 컨텍스트 내에서 선언된 변수, 함수, 매개변수 등에 대한 접근 규칙을 정의합니다.

2. **콜 스택과 실행 컨텍스트:** 콜 스택은 현재 실행 중인 실행 컨텍스트들을 순서대로 쌓아놓은 스택입니다. 콜 스택의 맨 위에는 현재 실행 중인 함수의 실행 컨텍스트가 위치하며, 그 아래에는 해당 함수를 호출한 함수의 실행 컨텍스트가 위치합니다. 이렇게 콜 스택은 함수 호출의 흐름을 추적하는 역할을 합니다.

3. **스코프 체인:** 스코프 체인은 현재 실행 컨텍스트의 스코프부터 시작하여 상위 스코프들을 차례대로 연결한 리스트입니다. 변수를 참조할 때 자바스크립트 엔진은 먼저 현재 실행 컨텍스트의 스코프에서 변수를 찾습니다. 만약 찾지 못하면 스코프 체인을 따라 상위 스코프로 이동하여 변수를 찾습니다. 이 과정은 변수가 발견되거나 전역 스코프에 도달할 때까지 계속됩니다.

**예시를 통한 이해**

```javascript
let x = 10; // 전역 변수

function outer() {
  let y = 20; // outer 함수의 지역 변수

  function inner() {
    let z = 30; // inner 함수의 지역 변수
    console.log(x + y + z); // 60
  }

  inner();
}

outer();
```

1. `outer()` 함수가 호출되면 새로운 실행 컨텍스트가 생성되고 콜 스택에 푸시됩니다. 이 실행 컨텍스트의 스코프 체인은 `inner()` 함수의 스코프 -> `outer()` 함수의 스코프 -> 전역 스코프 순서로 연결됩니다.

2. `inner()` 함수가 호출되면 또 다른 실행 컨텍스트가 생성되고 콜 스택에 푸시됩니다. 이 실행 컨텍스트의 스코프 체인은 `inner()` 함수의 스코프 -> `outer()` 함수의 스코프 -> 전역 스코프 순서로 연결됩니다.

3. `inner()` 함수 내부에서 `x + y + z`를 계산할 때, 자바스크립트 엔진은 먼저 `inner()` 함수의 스코프에서 `x`, `y`, `z` 변수를 찾습니다. `z`는 찾았지만 `x`와 `y`는 찾지 못하므로 스코프 체인을 따라 상위 스코프로 이동합니다.

4. `outer()` 함수의 스코프에서 `y`를 찾았지만 `x`는 찾지 못하므로 다시 스코프 체인을 따라 전역 스코프로 이동합니다.

5. 전역 스코프에서 `x`를 찾았으므로 모든 변수를 찾았고, 계산 결과 `60`을 출력합니다.

이처럼 콜 스택은 함수 호출의 흐름을 추적하고, 스코프 체인은 변수를 찾는 데 사용됩니다. 즉, 콜 스택의 각 실행 컨텍스트는 스코프 체인의 한 단계에 해당하며, 스코프 체인을 통해 변수 검색이 이루어집니다.
