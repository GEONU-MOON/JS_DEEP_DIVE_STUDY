## 전역 변수의 문제점
### 14.1 변수의 생명 주기
#### ____14.1.1 지역 변수의 생명 주기
지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.
변수의 생명 주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지이다. 

일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸한다. 하지만 누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존한다. 

호이스팅은 스코프를 단위로 동작한다. 

#### ____14.1.2 전역 변수의 생명 주기
함수와 달리 전역 코드는 명시적인 호출없이 실행된다. 즉 함수 호출과 같이 전역 코드를 실행하는 진입점이 없고 코드가 로드되자마마 곧바로 해석되고 실행된다.


---
### 14.2 전역 변수의 문제점
- **암묵적 결합** : 코드 어디서든 참조하고 변경 가능, 가독성 나빠짐, 의도치 않은 상태 변경 위험.
- **긴 생명 주기** : 메모리 리소스 오랜 기간 소비, 변수 상태 변경 시간 길고 기회 많음 -> 오류 확률 큼.
- **스코프 체인 상에서 종점에 존재** : 전역 변수가 가장 마지막에 검색됨(검색 속도 가장 느림).
- **네임스페이스 오염** : 파일 분리되어도 하나의 전역 스코프 공유, 다른 파일 동일 이름 변수나 함수 -> 오류.
---
### 14.3 전역 변수의 사용을 억제하는 방법
변수의 스코프는 좁을수록 좋다. 
#### ____14.3.1 즉시 실행 함수
모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

#### ____14.3.2 네임스페이스 객체
전역 네임스페이스 객체를 만들어 프로퍼티로 관리하는 방법이다. 어차피 전역 객체이기 때문에 그닥 좋은 방법은 아니다.

#### ____14.3.3 모듈 패턴
클로저를 활용해 클래스를 모방해서 만든 패턴이다.
전역 변수의 억제와 캡슐화까지 구현할 수 있다.

#### ____14.3.4 ES6 모듈
ES6 모듈을 사용하면 전역 변수를 사용할 수 없다. ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.

