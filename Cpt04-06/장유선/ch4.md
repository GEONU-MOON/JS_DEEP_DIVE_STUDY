## 4장 변수

### 4.1 변수란 무엇인가? 왜 필요한가?
#### 변수의 뜻
- **변수** : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름, **값의 위치**를 가리키는 상징적인 이름
  - **할당**(대입, 저장) : 변수에 값을 저장하는 것
  - **참조** : 변수에 저장된 값을 읽어 들이는 것
#### 사용하는 이유
- 값을 저장하여 **재사용** 하기 위해
- 값의 저장은 메모리에 저장하고, 연산은 cpu에서 한다.
---
### 4.2 식별자
**식별자**(변수 이름) : 어떤 값을 구별해서 식별할 수 있는 고유한 이름, 식별자는 값이 아니라 메모리 주소를 기억함
- 식별자의 종류: 변수명, 함수명, 클래스명 등
- 식별자 네이밍 규칙을 준수해야 하는 이유: 연산자 기호가 포함되어 있는 경우 자바스크립트 엔진이 식으로 판단하는 경우가 있음.

---
### 4.3 변수 선언
- 변수를 선언 한다는 것: 해당 식별자를 저장할 메모리의 주소값을 확보하는 것
-  선언 단계 : var, let, const 키워드 사용.
- 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화.

####  var 키워드를 사용한 변수 선언
- 선언 단계와 초기화 단계가 동시에 진행됨.
- var 키워드는 암묵적으로 초기화를 수행하므로 값을 할당하지 않고 참조하여 발생하는 에러로부터 안전하다.  

> 💡 요약하자면, var의 경우 선언과 초기화가 함께 이루어지며, let과 const는 선언과 초기화가 분리되어 있고, const는 선언과 동시에 반드시 초기화되어야 하며, 이후에는 재할당이 불가능하다.

---
### 4.4 변수 선언의 실행 시점과 변수 호이스팅
선언 이전에 호출할 경우:

- var: 선언되면서 자동으로 undefined가 할당(초기화)되어진 상태이므로 undefined 반환.
- let, const: **호이스팅**은 일어나지만 **TDZ**에 걸려 참조에러 발생.

> 💡 변수만 호이스팅 되는게 아님. 변수, 함수, 클래스 등 var, let, const, function, function*, class 키워드로 선언하는 모든 식별자는 호이스팅됨.

#### 호이스팅
호이스팅: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작.
            모든 선언문은 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점)
            이전 단계(소스코드 평가 과정)에서 먼저 실행됨.

#### TDZ
TDZ 내에서 변수에 접근 시 에러 발생: ReferenceError: Cannot access '변수명' before initialization

- TDZ의 정의: **스코프**의 시작 지점부터 초기화 지점까지의 영역
- var: 함수 스코프 이므로 함수가 아닌 조건문, 반복문 등에서 선언된 변수도 외부에서 접근이 가능하나 함수 안에서 선언된 변수는 외부에서 접근 불가능.
- let, const: 블록 스코프 이므로 함수, 조건문, 반복문 등 {}코드블럭 내에서 선언된 변수는 외부에서 접근 불가능.(ex: for문 밖에서 i에 접근하려고 하면 정의되지 않음을 알리는 에러 메세지 발생.)

#### 스코프
스코프란 단어의 뜻 그대로 '범위'라는 의미를 가지고있다. 코드에서의 스코프는 **'변수에 접근할 수 있는 범위'**라고 보면 된다.

자바스크립트의 스코프는 크게 전역 스코프(Global Scope)와 지역 스코프(Local Scope)로 나눌 수 있다.

- **전역 스코프(Global Scope)**
자바스크립트 코드의 최상위 레벨에 해당하는 스코프로 함수 어디에서든 접근이 가능하다.

- **지역 스코프(Local Scope)**
특정 함수에 해당하는 스코프로 해당 함수 자신과 하위 함수에서만 자원에 접근이 가능하다.

---
### 4.5 값의 할당
- 변수 선언: **런타임** 이전에 실행
- 값의 할당: **런타임**에 실행
```js
var num = 10; // 동작 순서를 알아보자.

var num; // undefined 할당
num = 10; // 10으로 재할당
```
- **런타임**: 소스코드가 한 줄씩 순차적으로 실행되는 시점

#### 변수에 값을 할당 시 원시타입과 참조타입의 메모리에 저장되는 값 비교
- 원시타입: 메모리 공간에 **실제 값**이 저장. (문자열, 숫자 등 )
- 참조타입: 메모리 공간에 **참조 값**이 저장. (배열, 객체, 함수 등)


---
### 4.6 값의 재할당
- 재할당 : 변수에 새로운 값을 또다시 할당
- 상수 : 값을 재할당 불가능, const키워드로 표현가능 (const키워드를 반드시 상수만을 위해 사용하지는 않음. 객체의 property변경 등) 
- 쓰레기 값: 변수에 값이 재할당되어 불필요해진 이전에 할당한 값. 이 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제됨.

---
### 4.7 식별자 네이밍 규칙
- 특수문자를 제외해야한다.
- 숫자로 시작할 수 없다.
- 예약어는 사용할 수 없다.

---
### 추가 공부

#### 초기화와 할당의 차이
- 초기화(initialization): 변수가 선언되고 값을 처음으로 할당하는 과정을 의미한다. 변수에 처음으로 값을 할당할 때 초기화가 이루어진다.
- 할당(assignment): 이미 선언된 변수에 값을 대입하는 과정을 의미한다. 초기화 이후에 변수에 값을 재할당할 때 할당이 이루어진다.
